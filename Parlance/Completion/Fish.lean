/-
  Parlance.Completion.Fish - Fish completion script generation
-/

import Parlance.Core.Types
import Parlance.Completion.Core

namespace Parlance.Completion.Fish

open Parlance
open Parlance.Completion

/-- Generate Fish completion value args for a flag based on ArgType -/
private def flagValueArgs (argType : Option ArgType) : String :=
  match argType with
  | none => "-f"  -- Boolean flag, no file completion
  | some .path => ""  -- Fish completes files by default
  | some (.choice opts) => s!"-f -a '{" ".intercalate opts}'"
  | some .bool => "-f -a 'true false yes no 1 0'"
  | some _ => "-x"  -- Exclusive (no file completion for other types)

/-- Generate a single complete command for a flag -/
private def generateFlagCompletion (_cmd : Command) (binaryName : String)
    (f : Flag) (condition : Option String := none) : String :=
  let condPart := match condition with
    | some cond => s!"-n '{cond}' "
    | none => ""
  let shortPart := match f.short with
    | some c => s!"-s {c} "
    | none => ""
  let valueArgs := flagValueArgs f.argType
  let requiresArg := if f.argType.isSome && valueArgs != "-f" then "-r " else ""
  let desc := escapeForShell f.description
  s!"complete -c {binaryName} {condPart}{shortPart}-l {f.long} {requiresArg}{valueArgs} -d '{desc}'"

/-- Generate all flag completions for a command -/
private def generateFlagCompletions (cmd : Command) (binaryName : String)
    (condition : Option String := none) : List String :=
  cmd.flags.toList.map fun f =>
    generateFlagCompletion cmd binaryName f condition

/-- Generate subcommand completions -/
private def generateSubcommandCompletions (cmd : Command) (binaryName : String) : List String :=
  cmd.subcommands.toList.map fun subcmd =>
    let desc := escapeForShell subcmd.description
    s!"complete -c {binaryName} -n '__fish_use_subcommand' -f -a '{subcmd.name}' -d '{desc}'"

/-- Generate completions for a subcommand's flags -/
private def generateSubcommandFlagCompletions (subcmd : Command) (binaryName : String) : List String :=
  let condition := s!"__fish_seen_subcommand_from {subcmd.name}"
  subcmd.flags.toList.map fun f =>
    generateFlagCompletion subcmd binaryName f (some condition)

/-- Generate a Fish completion script for a command -/
def generateScript (cmd : Command) (binaryName : String) : String :=
  let header := s!"# Fish completion for {binaryName}
# Generated by Parlance CLI Library
#
# Installation:
#   {binaryName} --generate-completion fish > ~/.config/fish/completions/{binaryName}.fish
"

  -- Root command flags (available when no subcommand is selected, or always if no subcommands)
  let rootFlags := if cmd.subcommands.isEmpty then
    generateFlagCompletions cmd binaryName none
  else
    -- When there are subcommands, root flags are available before any subcommand
    generateFlagCompletions cmd binaryName (some "__fish_use_subcommand")

  -- Subcommand completions
  let subcmdCompletions := generateSubcommandCompletions cmd binaryName

  -- Subcommand flag completions
  let subcmdFlagCompletions := cmd.subcommands.toList.flatMap fun subcmd =>
    generateSubcommandFlagCompletions subcmd binaryName

  -- Positional argument completions (for choice types)
  let argCompletions := cmd.args.toList.filterMap fun a =>
    match a.argType with
    | .choice opts =>
      let desc := escapeForShell a.description
      some s!"complete -c {binaryName} -f -a '{" ".intercalate opts}' -d '{desc}'"
    | _ => none

  let allLines := [header] ++
    [""] ++ rootFlags ++
    (if subcmdCompletions.isEmpty then [] else [""] ++ subcmdCompletions) ++
    (if subcmdFlagCompletions.isEmpty then [] else [""] ++ subcmdFlagCompletions) ++
    (if argCompletions.isEmpty then [] else [""] ++ argCompletions)

  "\n".intercalate allLines ++ "\n"

end Parlance.Completion.Fish
