/-
  Parlance.Completion.Bash - Bash completion script generation
-/

import Parlance.Core.Types
import Parlance.Completion.Core

namespace Parlance.Completion.Bash

open Parlance

/-- Generate completion action for a flag's value based on ArgType -/
private def flagValueCompletion (argType : Option ArgType) : String :=
  match argType with
  | none => ""  -- Boolean flag, no value completion
  | some .path => "COMPREPLY=($(compgen -f -- \"$cur\"))"
  | some (.choice opts) =>
    let optStr := " ".intercalate opts
    "COMPREPLY=($(compgen -W \"" ++ optStr ++ "\" -- \"$cur\"))"
  | some .bool => "COMPREPLY=($(compgen -W \"true false yes no 1 0\" -- \"$cur\"))"
  | some _ => ""  -- String, int, nat, float - no specific completions

/-- Generate case entries for flag value completion -/
private def generateFlagValueCases (cmd : Command) : String :=
  let cases := cmd.flags.toList.filterMap fun f =>
    match f.argType with
    | none => none  -- Boolean flag
    | some argType =>
      let completion := flagValueCompletion (some argType)
      if completion.isEmpty then none
      else
        let patterns := match f.short with
          | some c => "--" ++ f.long ++ "|-" ++ toString c
          | none => "--" ++ f.long
        some ("        " ++ patterns ++ ")\n            " ++ completion ++ "\n            return\n            ;;")
  "\n".intercalate cases

/-- Generate subcommand case handling -/
private def generateSubcommandCases (cmd : Command) (_binaryName : String) : String :=
  if cmd.subcommands.isEmpty then ""
  else
    let cases := cmd.subcommands.toList.map fun subcmd =>
      let subFlags := flagCompletions subcmd
      let subSubcmds := subcommandCompletions subcmd
      let allOpts := " ".intercalate (subFlags ++ subSubcmds)
      -- Also handle nested flag value completions
      let flagCases := generateFlagValueCases subcmd
      let flagHandling := if flagCases.isEmpty then "" else
        "\n            # Handle flag value completion for " ++ subcmd.name ++ "\n            case \"$prev\" in\n" ++ flagCases ++ "\n            esac"
      "        " ++ subcmd.name ++ ")" ++ flagHandling ++ "\n            COMPREPLY=($(compgen -W \"" ++ allOpts ++ "\" -- \"$cur\"))\n            ;;"
    let casesStr := "\n".intercalate cases
    -- Use plain string for shell variable syntax
    "\n        case \"${COMP_WORDS[1]}\" in\n" ++ casesStr ++ "\n        esac"

/-- Generate a Bash completion script for a command -/
def generateScript (cmd : Command) (binaryName : String) : String :=
  -- Sanitize the binary name for use as a function name
  let funcName := "_" ++ binaryName.replace "-" "_" ++ "_completions"

  let rootFlags := flagCompletions cmd
  let rootSubcmds := subcommandCompletions cmd
  let rootOpts := " ".intercalate (rootFlags ++ rootSubcmds)

  let flagValueCases := generateFlagValueCases cmd
  let flagValueSection := if flagValueCases.isEmpty then "" else
    "\n    # Handle flag value completion\n    case \"$prev\" in\n" ++ flagValueCases ++ "\n    esac\n"

  let subcmdSection := generateSubcommandCases cmd binaryName
  let subcmdHandling := if subcmdSection.isEmpty then
    "    COMPREPLY=($(compgen -W \"" ++ rootOpts ++ "\" -- \"$cur\"))"
  else
    "    # Handle command/subcommand completion\n" ++
    "    if [[ $COMP_CWORD -eq 1 ]]; then\n" ++
    "        COMPREPLY=($(compgen -W \"" ++ rootOpts ++ "\" -- \"$cur\"))\n" ++
    "    else" ++ subcmdSection ++ "\n    fi"

  -- Build the script using ++ for cleaner escaping
  let header := "# Bash completion for " ++ binaryName ++ "\n"
  let header := header ++ "# Generated by Parlance CLI Library\n"
  let header := header ++ "#\n"
  let header := header ++ "# Installation:\n"
  let header := header ++ "#   " ++ binaryName ++ " --generate-completion bash > ~/.bash_completion.d/" ++ binaryName ++ "\n"
  let header := header ++ "#   # Or add to ~/.bashrc:\n"
  let header := header ++ "#   #   source <(" ++ binaryName ++ " --generate-completion bash)\n"
  let header := header ++ "\n"

  -- Function definition
  let funcDef := funcName ++ "() {\n"
  let funcDef := funcDef ++ "    local cur prev words cword\n"
  let funcDef := funcDef ++ "    _init_completion 2>/dev/null || {\n"
  let funcDef := funcDef ++ "        COMPREPLY=()\n"
  let funcDef := funcDef ++ "        cur=\"${COMP_WORDS[COMP_CWORD]}\"\n"
  let funcDef := funcDef ++ "        prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n"
  let funcDef := funcDef ++ "    }\n"
  let funcDef := funcDef ++ "\n"
  let funcDef := funcDef ++ "    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n"
  let funcDef := funcDef ++ "    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n"
  let funcDef := funcDef ++ flagValueSection
  let funcDef := funcDef ++ subcmdHandling ++ "\n"
  let funcDef := funcDef ++ "}\n"

  let complete := "\ncomplete -F " ++ funcName ++ " " ++ binaryName ++ "\n"

  header ++ funcDef ++ complete

end Parlance.Completion.Bash
