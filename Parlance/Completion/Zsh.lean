/-
  Parlance.Completion.Zsh - Zsh completion script generation
-/

import Parlance.Core.Types
import Parlance.Completion.Core

namespace Parlance.Completion.Zsh

open Parlance
open Parlance.Completion

/-- Generate Zsh completion action for ArgType -/
private def argTypeAction (argType : Option ArgType) : String :=
  match argType with
  | none => ""
  | some .path => ":file:_files"
  | some (.choice opts) => s!": :({" ".intercalate opts})"
  | some .int => ": :"
  | some .nat => ": :"
  | some .float => ": :"
  | some .string => ": :"
  | some .bool => ": :(true false yes no 1 0)"

/-- Generate a flag specification for _arguments -/
private def flagSpec (f : Flag) : String :=
  let desc := escapeForShell f.description
  let action := argTypeAction f.argType
  -- Format: '(-s --long)'{-s,--long}'[description]action'
  -- Or for long-only: '--long[description]action'
  match f.short with
  | some c =>
    -- Use string concatenation to avoid complex escaping
    "'(-" ++ toString c ++ " --" ++ f.long ++ ")'{-" ++ toString c ++ ",--" ++ f.long ++ "}'[" ++ desc ++ "]" ++ action ++ "'"
  | none =>
    s!"'--{f.long}[{desc}]{action}'"

/-- Generate positional argument specs -/
private def argSpecs (cmd : Command) : List String :=
  cmd.args.toList.mapIdx fun idx a =>
    let n := idx + 1
    let action := match a.argType with
      | .path => "_files"
      | .choice opts => s!"({" ".intercalate opts})"
      | _ => ""
    if a.required then
      s!"'{n}:{a.name}:{action}'"
    else
      s!"'{n}::{a.name}:{action}'"

/-- Generate completion function for a subcommand -/
private def generateSubcommandFunction (subcmd : Command) (binaryName : String) : String :=
  let funcName := s!"_{binaryName.replace "-" "_"}_{subcmd.name.replace "-" "_"}"
  let flagSpecs' := subcmd.flags.toList.map flagSpec
  let argSpecs' := argSpecs subcmd
  let allSpecs := flagSpecs' ++ argSpecs'
  let specsStr := if allSpecs.isEmpty then "'*:file:_files'"
    else " \\\n        ".intercalate allSpecs

  -- Build function using concatenation
  funcName ++ "() {\n    _arguments -s \\\n        " ++ specsStr ++ "\n}"

/-- Generate a Zsh completion script for a command -/
def generateScript (cmd : Command) (binaryName : String) : String :=
  let funcName := s!"_{binaryName.replace "-" "_"}"

  let flagSpecs' := cmd.flags.toList.map flagSpec
  let argSpecs' := argSpecs cmd

  -- Generate subcommand functions
  let subcmdFuncs := cmd.subcommands.toList.map fun subcmd =>
    generateSubcommandFunction subcmd binaryName

  let subcmdHandling := if cmd.subcommands.isEmpty then "" else
    let caseEntries := cmd.subcommands.toList.map fun subcmd =>
      let subFuncName := s!"_{binaryName.replace "-" "_"}_{subcmd.name.replace "-" "_"}"
      s!"        {subcmd.name})\n            {subFuncName}\n            ;;"
    let caseEntriesStr := "\n".intercalate caseEntries
    let subcmdDescLines := cmd.subcommands.toList.map fun s =>
      s!"        '{s.name}:{escapeForShell s.description}'"
    let subcmdDescStr := "\n".intercalate subcmdDescLines
    -- Build using concatenation to avoid escaping issues
    "\n    # Handle subcommands\n    local -a subcmds\n    subcmds=(\n" ++
    subcmdDescStr ++ "\n    )\n\n" ++
    "    if (( CURRENT == 2 )); then\n" ++
    "        _describe 'command' subcmds\n" ++
    "    else\n" ++
    "        case \"${words[2]}\" in\n" ++
    caseEntriesStr ++ "\n" ++
    "        esac\n" ++
    "    fi"

  let rootArgs := if cmd.subcommands.isEmpty then
    let allSpecs := flagSpecs' ++ argSpecs'
    if allSpecs.isEmpty then "    _arguments -s '*:file:_files'"
    else s!"    _arguments -s \\\n        {" \\\n        ".intercalate allSpecs}"
  else
    let flagsOnly := if flagSpecs'.isEmpty then ""
      else s!"    _arguments -s \\\n        {" \\\n        ".intercalate flagSpecs'}\n"
    s!"{flagsOnly}{subcmdHandling}"

  let subcmdFuncsStr := if subcmdFuncs.isEmpty then ""
    else "\n\n" ++ "\n\n".intercalate subcmdFuncs

  -- Build header
  let header := s!"#compdef {binaryName}\n\n"
  let header := header ++ s!"# Zsh completion for {binaryName}\n"
  let header := header ++ "# Generated by Parlance CLI Library\n"
  let header := header ++ "#\n"
  let header := header ++ "# Installation:\n"
  let header := header ++ s!"#   {binaryName} --generate-completion zsh > ~/.zsh/completions/_{binaryName}\n"
  let header := header ++ "#   # Make sure ~/.zsh/completions is in your fpath\n\n"

  -- Build main function
  let mainFunc := funcName ++ "() {\n" ++ rootArgs ++ "\n}" ++ subcmdFuncsStr ++ "\n\n"
  let invocation := funcName ++ " \"$@\"\n"

  header ++ mainFunc ++ invocation

end Parlance.Completion.Zsh
